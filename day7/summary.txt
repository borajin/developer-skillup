

더블클릭시
input disabled 해제하고 포커스되게
키워드/주의키워드/플랫폼은 팝업창이 뜨게
포커스 해제시 글쓴 것 반영되게

라벨 변경 시
반영되게

=========

state = props ?

화면과 바인딩된 데이터!
그 데이터가 바뀌면 화면도 바뀌는 데이터!

props 는 내가 가진 데이터가 아니라
부모가 가지고 있는 데이터
(state 가 아니라 value 도 가능)
하지만 원칙을 state 를 props 로 전달한다고 세우면 좀 깔끔해짐 (필수는 아님)

=========

컴포넌트를 어떻게 쪼갤 것인가
state 를 무엇을 할것인가
state 를 어떤 컴포넌트에 넣을 것인가

=========

컴포넌트 쪼개기에 마크업이 적당하지 않으면
마크업팀에 요청해야 함
=========

state 로 화면을 바꿀 가장 작은 단위의 컴포넌트(set state 가 가장 최소로 일어나는 컴포넌트) 에 넣는게 최고~!


이유 : setState 를 호출한 컴포넌트의 자식 컴포넌트까지 다 렌더링하기 때문에 비효율적!

=========

리액트 라이프사이클 :  화면이 한번 바뀌는 싸이클

리엑트에서 화면이 바뀔 땐 reder 가 호출되어야~

생길 때 : Mounting
없어질 때 :Unmounting
갱신될때 : updation


updation : render () 로 보면 됨

render 가 일어날 때는
자기 안에서 setState 를 하거나
props 로 전달받은 state 가 setState가 될 때임.
또… 부모 컴포넌트에서 자식 컴포너ㄴ트가 안 쓰는 state 를 set 할때도 바뀜.. (비효율적!)
-> 이를 위해 만든 shouldComponentUpdata 

shouldComponentUpdata
update 싸이클에서 맨 처음 실행됨
past state, props 와 current state, props 를 주면서 화면 바꿀것인지 물어보는 함수(true, false)


=====

PureComponent 를 상속받으면
자기가 안 쓰는 state 변경되었을 때 render 안하게 자동으로 알아서 처리해줌.

=====

function 에서는 memo 를 쓰면됨~

const Name = memo(() => {})

여기서 주의할 점!
reference 를 가지는 Object 를 porps 든 state 든 던지면
push를 해도 같은 reference 이므로
render 가 안됨

======

리액트는 Key 값이 같은 걸 같은 애로 보기 때문에
다음 랜더 때도 key 값이 같도록 해줘야 리액트가 알아서 최적하하므로 제일 효율적임.

ex) map 할 때 index 자동으로 생성하지말고
고유 id 값을 key 로 생성하기.

====

다음 시간엔
프론트 next.js 알아보기~